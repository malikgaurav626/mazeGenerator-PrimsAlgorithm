<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"
        integrity="sha512-qZvrmS2ekKPF2mSznTQsxqPgnpkI4DNTlrdUmTzrDgektczlKNRRhy5X5AAOnx5S09ydFYWWNSfcEqDTTHgtNA=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous" />
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-kenU1KFdBIe4zVF0s0G1M5b4hcpxyD9F7jL+jjXkk+Q2h455rYXK/7HAuoJl+0I4"
        crossorigin="anonymous"></script>
    <style>
        input:focus {
            outline: 2px solid white;
            /* Desired outline style */
        }

        ::placeholder {
            color: white;
            /* Desired placeholder color */
        }

        body {
            padding-left: 5%;
            padding-right: 5%;
        }

        table {
            border-collapse: collapse;
        }

        td {
            border: 1px solid black;
            padding: 5px;
        }

        .matrix-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            margin-top: 30px;
        }

        #table-id {
            text-align: center;
            border: 1px solid black;
        }

        .matrix {
            margin-top: 30px;
        }

        #generateMazeButton {
            border:2px solid #a6b1e1;
            border-radius: 5px;
            margin-top: 20px;
            transition: 0.2s ease-in;
        }
        #generateMazeButton:hover{
            border:2px solid white;
            transition: 0.2s ease-out;
        }

        #savePdfButton {
            border:2px solid #a6b1e1;
            border-radius: 5px;
            margin-top: 20px;
            transition: 0.2s ease-out;
        }
        #savePdfButton:hover{
            border:2px solid white;
            transition: 0.2s ease-in;
        }

        @media (max-width: 566px) {
            .matrix {
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .matrix label,
            .matrix input {
                display: block;
                margin-bottom: 1em;
            }

            #generateMazeButton {
                margin-top: -20px;
            }

            #savePdfButton {
                margin-top: -20px;
            }
        }
    </style>
</head>

<body style="background-color: #a6b1e1" class="text-center">
    <div class="matrix mt-3 text-center">
        <!-- <label for="rows">Rows:</label> -->
        <input placeholder="Rows"
            style="color: white; background: linear-gradient(to right,#34e89e,#4568DC); border: none; border-radius: 3px; display: inline-block;"
            type="number" id="rows" min="2" />
        <!-- <label for="cols">Columns:</label> -->
        <input placeholder="Columns"
            style="color: white; background: linear-gradient(to left,#34e89e,#4568DC); border: none; border-radius: 3px; display: inline-block;"
            type="number" id="cols" min="2" />
        <br />
        <div class="contain">
            <button id="generateMazeButton" onclick="createMatrix()" class="btn btn-sm"
                style="background: linear-gradient(to right,#4568DC,#B06AB3); color: white">
                Generate Maze
            </button>
            <button onclick="saveElementAsPdf()" id="savePdfButton" class="btn btn-sm"
                style="background: linear-gradient(to right,#4568DC,#B06AB3); color: white">Save as
                PDF</button>
        </div>
    </div>
    </div>


    <div class="matrix-container" id="matrix-container"></div>
    </div>



    <script src="https://html2canvas.hertzen.com/dist/html2canvas.js"></script>

    <script>
        const jsPDF = window.jspdf.jsPDF;
        function saveElementAsPdf() {
            const elementToSave = document.getElementById("table-id");

            html2canvas(elementToSave).then(canvas => {
                const imageData = canvas.toDataURL("image/png");

                // Get the dimensions of the element
                const elementWidth = elementToSave.offsetWidth;
                const elementHeight = elementToSave.offsetHeight;

                // Create a new jsPDF instance with custom page size
                const pdf = new jsPDF({
                    format: [elementWidth + 50, elementHeight + 100] // Add some extra padding
                });

                // Calculate the horizontal and vertical centering positions
                const positionX = (pdf.internal.pageSize.getWidth() - elementWidth) / 2;
                const positionY = (pdf.internal.pageSize.getHeight() - elementHeight) / 2;

                // Add the image to the PDF at the center position
                pdf.addImage(imageData, "PNG", positionX, positionY, elementWidth, elementHeight);

                pdf.save("Maze.pdf");
            });
        }



        function createMatrix() {
            // Get the dimensions from the input fields
            var rows = parseInt(document.getElementById("rows").value);
            var cols = parseInt(document.getElementById("cols").value);

            let container = document.getElementById("matrix-container");
            container.innerHTML = "";
            container.style.cssText = `text-align: center; border-collapse:collapse;`;
            let newElement = document.createElement("table");
            newElement.id = "table-id";
            newElement.style.cssText = "border 1px solid black";
            container.appendChild(newElement);
            for (let i = 0; i < rows; i++) {
                addRow(i);
                for (let j = 0; j < cols; j++) {
                    addCol(i, j, rows, cols);
                }
            }
            let maze = new Maze(rows, cols);
            maze.generate();
            maze.display();
        }
        function addRow(i) {
            let container = document.getElementById("table-id");
            let newElement = document.createElement("tr");
            newElement.classList.add("table-row");
            newElement.id = `t-row-${i}`;
            container.appendChild(newElement);
        }
        function addCol(i, j, rows, cols) {
            let windowWidth =
                window.innerWidth ||
                document.documentElement.clientWidth ||
                document.body.clientWidth;
            let maxPadding = Math.floor(windowWidth / (cols + 1));

            let padding = Math.min(maxPadding, 10);
            let container = document.getElementById("t-row-" + i);
            let newElement = document.createElement("td");
            newElement.classList.add("table-data");
            newElement.id = `t-data-${i}-${j}`;
            newElement.style.cssText = `border: 1px solid #424874; padding: ${padding}px; position: relative;`;
            container.appendChild(newElement);
        }
        class matrix_element {
            constructor() {
                this.top = true;
                this.bottom = true;
                this.left = true;
                this.right = true;
                this.visited = false;
                this.frontier = false;
            }
        }
        class cords {
            constructor() {
                this.row = 0;
                this.col = 0;
            }
            give_cords() {
                let cordinates = [];
                cordinates.push(this.row);
                conrdinates.push(this.col);
                return cordinates;
            }
        }
        class Maze {
            constructor(rows, cols) {
                this.rows = rows;
                this.cols = cols;
                this.matrix = [];
                for (let i = 0; i < rows; i++) {
                    this.matrix[i] = [];
                }
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        this.matrix[i][j] = new matrix_element();
                    }
                }
            }
            adjacent_cells(random_cell) {
                let cellList = [];
                let row = random_cell.row;
                let col = random_cell.col;
                if (row > 0) {
                    let temp = new cords();
                    temp.col = col;
                    temp.row = row - 1;
                    cellList.push(temp);
                }
                if (row < this.rows - 1) {
                    let temp = new cords();
                    temp.col = col;
                    temp.row = row + 1;
                    cellList.push(temp);
                }
                if (col < this.cols - 1) {
                    let temp = new cords();
                    temp.col = col + 1;
                    temp.row = row;
                    cellList.push(temp);
                }
                if (col > 0) {
                    let temp = new cords();
                    temp.col = col - 1;
                    temp.row = row;
                    cellList.push(temp);
                }

                return cellList;
            }
            addToFrontier(cellList) {
                for (let ele of cellList) {
                    if (this.matrix[ele.row][ele.col].visited === false) {
                        this.matrix[ele.row][ele.col].frontier = true;
                    }
                }
            }
            getFrontierSet() {
                let frontierSet = [];
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (this.matrix[i][j].frontier == true) {
                            let temp = new cords();
                            temp.row = i;
                            temp.col = j;
                            frontierSet.push(temp);
                        }
                    }
                }
                return frontierSet;
            }
            getAdjacentCellVisited(cell) {
                let cellList = [];
                let row = cell.row;
                let col = cell.col;
                if (row > 0) {
                    let temp = new cords();
                    temp.col = col;
                    temp.row = row - 1;
                    cellList.push(temp);
                }
                if (row < this.rows - 1) {
                    let temp = new cords();
                    temp.col = col;
                    temp.row = row + 1;
                    cellList.push(temp);
                }
                if (col < this.cols - 1) {
                    let temp = new cords();
                    temp.col = col + 1;
                    temp.row = row;
                    cellList.push(temp);
                }
                if (col > 0) {
                    let temp = new cords();
                    temp.col = col - 1;
                    temp.row = row;
                    cellList.push(temp);
                }

                let adjacentcells = [];
                for (let i = 0; i < cellList.length; i++) {
                    if (this.matrix[cellList[i].row][cellList[i].col].visited) {
                        adjacentcells.push(cellList[i]);
                    }
                }
                return adjacentcells;
            }
            breakWall(currentCell, randomAdjacentCellVisited) {
                let rowDiff = currentCell.row - randomAdjacentCellVisited.row;
                let colDiff = currentCell.col - randomAdjacentCellVisited.col;

                if (rowDiff === 1) {
                    this.matrix[currentCell.row][currentCell.col].top = false;
                    this.matrix[randomAdjacentCellVisited.row][
                        randomAdjacentCellVisited.col
                    ].bottom = false;
                } else if (rowDiff === -1) {
                    this.matrix[currentCell.row][currentCell.col].bottom = false;
                    this.matrix[randomAdjacentCellVisited.row][
                        randomAdjacentCellVisited.col
                    ].top = false;
                } else if (colDiff === 1) {
                    this.matrix[currentCell.row][currentCell.col].left = false;
                    this.matrix[randomAdjacentCellVisited.row][
                        randomAdjacentCellVisited.col
                    ].right = false;
                } else if (colDiff === -1) {
                    this.matrix[currentCell.row][currentCell.col].right = false;
                    this.matrix[randomAdjacentCellVisited.row][
                        randomAdjacentCellVisited.col
                    ].left = false;
                }
            }

            generate() {
                let random_cell = new cords();
                random_cell.row = Math.floor(Math.random() * this.rows);
                random_cell.col = Math.floor(Math.random() * this.cols);

                this.matrix[random_cell.row][random_cell.col].visited = true;
                let adjacent_cells = this.adjacent_cells(random_cell);

                this.addToFrontier(adjacent_cells);

                while (this.getFrontierSet().length > 0) {
                    let frontierSet = this.getFrontierSet();
                    let frontierCellIndex = Math.floor(
                        Math.random() * frontierSet.length
                    );

                    let randomFrontierCell = frontierSet[frontierCellIndex];
                    random_cell = randomFrontierCell;
                    this.matrix[randomFrontierCell.row][
                        randomFrontierCell.col
                    ].frontier = false;
                    this.matrix[randomFrontierCell.row][
                        randomFrontierCell.col
                    ].visited = true;

                    let adjacentCellVisitedList =
                        this.getAdjacentCellVisited(random_cell);
                    let randomAdjacentCellVisitedIndex = Math.floor(
                        Math.random() * adjacentCellVisitedList.length
                    );
                    let randomAdjacentCellVisited =
                        adjacentCellVisitedList[randomAdjacentCellVisitedIndex];

                    this.breakWall(random_cell, randomAdjacentCellVisited);

                    adjacent_cells = this.adjacent_cells(random_cell);
                    this.addToFrontier(adjacent_cells);
                }
            }
            display() {
                let original = document.getElementById("matrix-container");
                for (let i = 0; i < this.rows; i++) {
                    for (let j = 0; j < this.cols; j++) {
                        if (!this.matrix[i][j].top) {
                            document.getElementById(`t-data-${i}-${j}`).style.borderTop =
                                "none";
                        }
                        if (!this.matrix[i][j].bottom) {
                            document.getElementById(`t-data-${i}-${j}`).style.borderBottom =
                                "none";
                        }
                        if (!this.matrix[i][j].left) {
                            document.getElementById(`t-data-${i}-${j}`).style.borderLeft =
                                "none";
                        }
                        if (!this.matrix[i][j].right) {
                            document.getElementById(`t-data-${i}-${j}`).style.borderRight =
                                "none";
                        }
                    }
                }
            }
        }
    </script>
</body>

</html>